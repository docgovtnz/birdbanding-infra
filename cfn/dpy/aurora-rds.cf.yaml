---
# This template creates a postgreSQL Aurora database cluster with a rotating key

AWSTemplateFormatVersion: '2010-09-09'
Description: 'DOC Data Service Template - Aurora postgresql cluster'

## ::METADATA::
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
    #---------------
    - Label:
        default: 'General Parameters'
      Parameters:
        - environment
        - serviceName

    - Label:
        default: 'Database Configuration Parameters'
      Parameters:
        - DBName
        - DBSnapshotArn

    - Label:
        default: 'Lambda Access Cross-References'
      Parameters:
        - referenceLambdaSubnetIdList
        - referenceLambdaSecurityGroupId

    - Label:
        default: 'Cross References'
      Parameters:
        - referenceVpcId
        - referenceClusterSecurityGroupId
        - referenceSubnetIdList
        - referenceBastionSecurityGroupId
        - referenceZoneStack
        - referenceAlertStack
        - referenceUserAssetsS3BucketArn

    # LABELS
    ParameterLabels:
    #---------------
      # General Parameters

      serviceName:
        default: "Data Service name:"
      environment:
        default: "Environment:"

      # Database Parameters

      DBName:
        default: "Database name"
      DBSnapshotArn:
        default: "Database Snapshot ARN"

      # Lambda Access Cross References

      referenceLambdaSubnetIdList:
        default: "List of Lambda subnet IDs:"
      referenceLambdaSecurityGroupId:     
        default: "ID of Lambda security group:"        

      # Cross References

      referenceVpcId:
        default: "VPC ID:"
      referenceClusterSecurityGroupId:
        default: "ID of Datastore security group:"
      referenceBastionSecurityGroupId:
        default: "ID of Bastion security group:"
      referenceSubnetIdList:
        default: "List of data subnet IDs:"
      referenceZoneStack:
        default: 'Private R53 Zone Cloudformation stack name:'
      referenceAlertStack:
        default: 'Alerting Cloudformation stack name:'
      referenceUserAssetsS3BucketArn:
        default: 'User Assets S3 bucket ARN:'

## ::PARAMETERS::
Parameters:

  # General Parameters

  serviceName:
    Type: String
    ConstraintDescription: "Must be between 3 - 32 characters long."
    AllowedPattern: "^[A-Za-z0-9]{3,32}$"
    MinLength: 4
    MaxLength: 32
    Default: "unknowndataservice"

  environment:
    Type: String
    AllowedValues:
    - "Example"
    Default: "Example"

  # Database Parameters

  DBName:
    Type: String
    ConstraintDescription: "Must begin with a letter and contain only alphanumeric characters."
    AllowedPattern: "[a-zA-Z][a-zA-Z0-9]*"
    MinLength: 1
    MaxLength: 64

  DBSnapshotArn:
    Type: String
    Description: 'Optional. If omitted, a new DB cluster is created. If included, must be the valid ARN of an existing snapshot.'
    Default: ''

  # Lamdba Access Cross-References

  referenceLambdaSubnetIdList:
    Type: "List<AWS::EC2::Subnet::Id>"
    Description: 'Required. Must reference existing lambda subnet IDs.'

  referenceLambdaSecurityGroupId:
    Type: "AWS::EC2::SecurityGroup::Id"
    Description: 'Required. This is the security group into which all Lambda functions are placed.'

  # Cross Reference Parameters

  referenceVpcId:
    Type: "AWS::EC2::VPC::Id"
    Description: 'Must reference a valid VPC.'

  # We use a string here so we can make the parameter optional
  referenceClusterSecurityGroupId:
    Type: String
    Description: 'Optional. If included, the cluster is created in this group. If omitted, a new Security Group is created.'
    Default: ''

  # We use a string here so we can make the parameter optional
  referenceBastionSecurityGroupId:
    Type: String
    Description: 'Optional. If included, ingress from the bastion group is added'
    Default: ''

  referenceSubnetIdList:
    Type: "List<AWS::EC2::Subnet::Id>"
    Description: 'Must reference existing subnet IDs.'

  referenceZoneStack:
    Description: 'Optional. If included, must be based on vpc/zone-*.yaml template.'
    Type: String
    Default: ''

  referenceAlertStack:
    Description: 'Optional. If included,must be based on operations/alert.yaml template.'
    Type: String
    Default: ''

  referenceUserAssetsS3BucketArn:
    Type : 'AWS::SSM::Parameter::Value<String>'
    Description: 'Must exist in the SSM parameter store'

## ::CONDITIONS::
Conditions:
  UsingExistingAlertTopic: !Not [!Equals [!Ref referenceAlertStack, '']]
  UsingR53Zone: !Not [!Equals [!Ref referenceZoneStack, '']]
  UsingSnapshot: !Not [ !Equals [ !Ref DBSnapshotArn,'' ]]
  CreateLocalSecurityGroup: !Equals [ !Ref referenceClusterSecurityGroupId,'' ]
  ReferenceBastionSGDefined: !Not [ !Equals [ !Ref referenceBastionSecurityGroupId,'' ]]
  NotUsingSnapshot: !Not [ !Condition UsingSnapshot ]
  IsNotExampleEnv: !Not [!Or [!Equals [ !Ref environment, 'Sandpit' ], !Equals [ !Ref environment, 'Example' ]]]
  IsExampleEnv: !Not [ !Condition IsNotExampleEnv ]
  IsNotExampleAndUsingR53Zone: !And
    - !Condition IsNotExampleEnv
    - !Condition UsingR53Zone
  IsNotExampleAndUsingExistingAlertTopic: !And
    - !Condition IsNotExampleEnv
    - !Condition UsingExistingAlertTopic
  UsinglocalSGAndBastionSGDefined: !And
    - !Condition CreateLocalSecurityGroup
    - !Condition ReferenceBastionSGDefined
  IsExampleEnvAndLocalSecurityGroup: !And
    - !Condition IsExampleEnv
    - !Condition CreateLocalSecurityGroup

## ::MAPPINGS::
Mappings:

  # Environment-Specific Config
  EnvConfig:
    Example:
      EnvToLower: 'example'
      AccountPrefix: 'exampleprefix'

  DBClusterConfig:
    Example:
      BackupRetentionPeriod: 1
      PortNumber: 5432
      PreferredBackupWindow: '14:00-15:00'
      PreferredMaintenanceWindow: 'Sun:16:15-Sun:17:30'
      StorageEncrypted: False
      Engine:  'aurora-postgresql'
      EngineVersion: 10.13

  DBInstanceConfig:
    Example:
      AllowMajorVersionUpgrade: False
      AutoMinorVersionUpgrade: False      
      MultiAZ: False
      InstanceType: db.r5.large
      Engine:  'aurora-postgresql'
      EngineVersion: 10.13
      PubliclyAccessible: False   
      MonitoringInterval: 0
      PerformanceInsightsRetentionPeriod: 7

## ::RESOURCES::
Resources:

  ## ===================================
  ## SECURITY CONFIGURATION
  ## ===================================

  # DATABASE SECURITY GROUP
  
  # This security group should be created here if we desire very
  # granular control over access to this cluster, and the cluster
  # is intended to reside in its own specific security group. If
  # that's the case, we need to pass in the IDs of any security
  # groups that must be allowed ingress into it. This
  # basically means the Lambda security group and bastion security
  # group if we're using one.

  # Alternatively, if this cluster should be placed into an existing
  # pre-configured security group, the parameter referenceClusterSecurityGroupId
  # is passed to this template, and that security group is used as-is.
  # The reference security group is NOT updated, the cluster is just
  # placed straight into it and the local SG is not created.
  LocalClusterSecurityGroup:
    Type: 'AWS::EC2::SecurityGroup'
    Condition: CreateLocalSecurityGroup
    Properties:
      GroupDescription: !Sub '${serviceName}-${environment}-${DBName}-security-group'
      VpcId: !Ref "referenceVpcId"
      Tags:
      - Key: Name
        Value: !Sub '${AWS::StackName}-AuroraLocalClusterSecurityGroup'

  # Access from Bastion 
  LocalClusterSecurityGroupBastionIngress:
    Type: 'AWS::EC2::SecurityGroupIngress'
    Condition: UsinglocalSGAndBastionSGDefined
    Properties:
      Description: 'Access from Bastion Host Security Group'
      GroupId: !GetAtt 'LocalClusterSecurityGroup.GroupId'
      IpProtocol: tcp
      FromPort: !FindInMap [ DBClusterConfig, !Ref environment, PortNumber ]
      ToPort: !FindInMap [ DBClusterConfig, !Ref environment, PortNumber ]
      SourceSecurityGroupId: !Ref referenceBastionSecurityGroupId
        
  # Access from Lambda
  LocalClusterSecurityGroupLambdaIngress:
    Type: 'AWS::EC2::SecurityGroupIngress'
    Condition: CreateLocalSecurityGroup
    Properties:
      Description: 'Access from Lambda Security Group'
      GroupId: !GetAtt 'LocalClusterSecurityGroup.GroupId'
      IpProtocol: tcp
      FromPort: !FindInMap [ DBClusterConfig, !Ref environment, PortNumber ]
      ToPort: !FindInMap [ DBClusterConfig, !Ref environment, PortNumber ]
      SourceSecurityGroupId: !Ref referenceLambdaSecurityGroupId

  # Access from Self
  LocalClusterSecurityGroupIngress:
    Type: 'AWS::EC2::SecurityGroupIngress'
    Condition: CreateLocalSecurityGroup
    Properties:
      GroupId: !GetAtt 'LocalClusterSecurityGroup.GroupId'
      IpProtocol: -1
      SourceSecurityGroupId: !Ref LocalClusterSecurityGroup
      Description: 'Self Reference'  

  # Access from Workspaces
  LocalClusterSecurityGroupWorkspaceIngress:
    Type: 'AWS::EC2::SecurityGroupIngress'
    Condition: IsExampleEnvAndLocalSecurityGroup
    Properties:
      GroupId: !GetAtt 'LocalClusterSecurityGroup.GroupId'
      IpProtocol: tcp
      FromPort: !FindInMap [ DBClusterConfig, !Ref environment, PortNumber ]
      ToPort: !FindInMap [ DBClusterConfig, !Ref environment, PortNumber ]      
      CidrIp: "10.202.0.0/16"
      Description: 'Access from Workspaces'

  # Access from National Office
  LocalClusterSecurityGroupNationalOfficeIngress:
    Type: 'AWS::EC2::SecurityGroupIngress'
    Condition: IsExampleEnvAndLocalSecurityGroup
    Properties:
      GroupId: !GetAtt 'LocalClusterSecurityGroup.GroupId'
      IpProtocol: tcp
      FromPort: !FindInMap [ DBClusterConfig, !Ref environment, PortNumber ]
      ToPort: !FindInMap [ DBClusterConfig, !Ref environment, PortNumber ]      
      CidrIp: "10.4.0.0/16"
      Description: 'Access from National Office (Any)'

  ## ===================================
  ## SECRET MANAGEMENT
  ## ===================================

  # Create a secret with the username admin and a randomly generated password in JSON.
  AuroraMasterSecret:
    Condition: NotUsingSnapshot
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub '${environment}/${serviceName}/aurora-pg'
      Description: !Sub 'Aurora PostgreSQL Master User Secret for ${serviceName} service in ${environment}'
      GenerateSecretString:
        SecretStringTemplate: '{"username": "master"}'
        GenerateStringKey: "password"
        ExcludeCharacters: '"@/\'
        PasswordLength: 16

  # Update the referenced secret with properties of the RDS database.
  # This is required to enable rotation. Note that the Aurora Cluster
  # is our target rather than individual instances.
  AuroraMasterSecretAttachment:
    Condition: NotUsingSnapshot
    Type: AWS::SecretsManager::SecretTargetAttachment
    Properties:
      SecretId: !Ref AuroraMasterSecret
      TargetId: !Ref AuroraDBCluster
      TargetType: AWS::RDS::DBCluster

  # Aurora Master Secret resource policy
  AuroraSecretResourcePolicy:
    Condition: NotUsingSnapshot
    Type: AWS::SecretsManager::ResourcePolicy
    Properties:
      SecretId: !Ref AuroraMasterSecret
      ResourcePolicy:
        Version: "2012-10-17"
        Statement:
          -
            Effect: "Deny"
            Principal:
              AWS: !Sub "arn:aws:iam::${AWS::AccountId}:root"
            Action: "secretsmanager:DeleteSecret"
            Resource: "*"
  
  # Lambda execution role for secret rotation Lambda
  CreateSecretRotationLambdaRole:
    Condition: NotUsingSnapshot
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: 
              - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: "/"
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole'
        - 'arn:aws:iam::aws:policy/SecretsManagerReadWrite'
        - 'arn:aws:iam::aws:policy/IAMFullAccess'
      Policies:
        - 
          PolicyName: "AdditionalPermissions"
          PolicyDocument: 
            Version: "2012-10-17"
            Statement: 
              - 
                Effect: "Allow"
                Action:
                  - "cloudformation:DescribeStackResources"
                  - "cloudformation:DeleteStack"
                Resource: "*"
              - 
                Effect: "Allow"
                Action:
                  - "lambda:DeleteFunction"
                  - "lambda:GetFunctionConfiguration"
                Resource: "arn:aws:lambda:*:*:function:SecretsManager*"

  # TODO! Reinsert this once the pipeline is up and running  
  # # Lambda Function to manage secret rotation
  # CreateSecretRotationLambdaFn:
  #   Condition: NotUsingSnapshot
  #   Type: AWS::Lambda::Function
  #   DependsOn:
  #     - CreateSecretRotationLambdaRole
  #   Properties:
  #     Code:
  #       ZipFile: |
  #         from __future__ import print_function
  #         import cfnresponse
  #         import boto3
          
  #         def lambda_handler(event, context):
  #             slrepoclient = boto3.client('serverlessrepo')
  #             cfclient = boto3.client('cloudformation')
  #             lambdaclient = boto3.client('lambda')
  #             SecretsManagerEndpoint = event['ResourceProperties']['SecretsManagerEndpoint']
  #             SecretRotationLambdaFnName = event['ResourceProperties']['SecretRotationLambdaFnName']
  #             SecretRotationLambdaStackName = event['ResourceProperties']['SecretRotationLambdaStackName']
  #             SubnetIds = event['ResourceProperties']['SubnetIds']
  #             SecretRotationLambdaSG = event['ResourceProperties']['SecretRotationLambdaSG']
              
  #             responseData = {}
               
  #             try: 
  #                 if event['RequestType'] == 'Create':
  #                     serverlessreporesponse = slrepoclient.create_cloud_formation_change_set(ApplicationId='arn:aws:serverlessrepo:us-east-1:00000000:applications/SecretsManagerRDSPostgreSQLRotationSingleUser', 
  #                     ParameterOverrides=[
  #                         {
  #                             'Name': 'endpoint',
  #                             'Value': SecretsManagerEndpoint
  #                         },
  #                         {
  #                             'Name': 'functionName',
  #                             'Value': SecretRotationLambdaFnName
  #                         },
  #                     ],
  #                     StackName=SecretRotationLambdaStackName)
  #                     print("StackName")
  #                     print(StackName)
  #                     waiter = cfclient.get_waiter('change_set_create_complete')
  #                     waiter.wait(ChangeSetName=serverlessreporesponse['ChangeSetId'],WaiterConfig={'Delay': 10,'MaxAttempts': 3})
                      
  #                     cloudformationresponse = cfclient.execute_change_set(ChangeSetName=serverlessreporesponse['ChangeSetId'])
  #                     print("CFN Response:")
  #                     print(cloudformationresponse)
  #                     waiter = cfclient.get_waiter('stack_create_complete')
  #                     waiter.wait(StackName=serverlessreporesponse['StackId'],WaiterConfig={'Delay': 10,'MaxAttempts': 3})
                      
  #                     lambdaresponse = lambdaclient.add_permission(FunctionName=SecretRotationLambdaFnName,StatementId='SecretsManagerAccess',Action='lambda:InvokeFunction',Principal='secretsmanager.amazonaws.com')
  #                     lambdaresponse = lambdaclient.update_function_configuration(FunctionName=SecretRotationLambdaFnName,VpcConfig={'SubnetIds': SubnetIds,'SecurityGroupIds': SecretRotationLambdaSG})
                      
  #                     responseData['Data'] = "SUCCESS: Secret Rotation Lambda created successfully."
  #                     responseData['SecretRotationLambdaARN'] = lambdaclient.get_function(FunctionName=SecretRotationLambdaFnName)['Configuration']['FunctionArn']
                      
  #                     cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData, "None")               
  #                 elif event['RequestType'] == 'Delete':
  #                     SecretRotationLambdaStackName = cfclient.describe_stack_resources(PhysicalResourceId=SecretRotationLambdaFnName,LogicalResourceId='SecretsManagerRDSPostgreSQLRotationSingleUser')['StackResources'][0]['StackName']
  #                     print("Delete Stack Name:")
  #                     print(SecretRotationLambdaStackName)
  #                     response = cfclient.delete_stack(StackName=SecretRotationLambdaStackName)
  #                     print("Response:")
  #                     print(response)
  #                     waiter = cfclient.get_waiter('stack_delete_complete')
  #                     waiter.wait(StackName='string',WaiterConfig={'Delay': 10,'MaxAttempts': 3})
                      
  #                     responseData['Data'] = "SUCCESS: Stack delete complete."
  #                     cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData, "None")
  #                 else:
  #                     responseData['Data'] = "{} is unsupported stack operation for this lambda function.".format(event['RequestType'])
  #                     cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData, "None")
  #             except Exception as e:
  #                 print(e)
  #                 responseData['Data'] = "ERROR: Exception encountered!"
  #                 cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData, "None")
  #     Description: >-
  #         Create Secret Rotation Lambda function using AWS Serverless Application Repository with template provided by AWS Secrets Manager
  #     Handler: index.lambda_handler
  #     MemorySize: 128
  #     Role: !GetAtt CreateSecretRotationLambdaRole.Arn
  #     Runtime: python2.7
  #     Timeout: 120
  #     VpcConfig: 
  #       SecurityGroupIds:
  #         - !Ref referenceLambdaSecurityGroupId
  #       SubnetIds: !Ref referenceLambdaSubnetIdList

  # # Lambda Function Trigger
  # CreateSecretRotationLambdaFnTrigger:
  #   Condition: NotUsingSnapshot
  #   Type: Custom::LambdaAPGSecretsManager
  #   Version: "1.0"
  #   Properties:
  #     ServiceToken: !GetAtt 'CreateSecretRotationLambdaFn.Arn'
  #     SecretsManagerEndpoint: !Sub 'https://secretsmanager.${AWS::Region}.amazonaws.com'
  #     SecretRotationLambdaFnName: !Sub 'SecretsManager-SecretRotationFn-${AWS::StackName}'
  #     SecretRotationLambdaStackName: !Sub '${AWS::StackName}-SecretRotationLambdaStack'
  #     SubnetIds: !Ref referenceLambdaSubnetIdList
  #     SecretRotationLambdaSG:
  #       - !Ref referenceLambdaSecurityGroupId
        
  # # Lambda Function rotation schedule
  # AuroraSecretRotationSchedule:
  #   Condition: NotUsingSnapshot
  #   Type: AWS::SecretsManager::RotationSchedule
  #   DependsOn:
  #     - AuroraMasterSecretAttachment
  #     - AuroraDBInstance1
  #   Properties:
  #     SecretId: !Ref AuroraMasterSecret
  #     RotationLambdaARN: !GetAtt CreateSecretRotationLambdaFnTrigger.SecretRotationLambdaARN
  #     RotationRules:
  #       AutomaticallyAfterDays: 30

  ## ===================================
  ## NETWORK CONFIGURATION
  ## ===================================

  # DATABASE SUBNET GROUP        
  AuroraDBSubnetGroup:
    Type: 'AWS::RDS::DBSubnetGroup'
    Properties:
      DBSubnetGroupDescription: !Sub '${environment}-${serviceName}-${DBName}-subnet-group'
      SubnetIds: !Ref referenceSubnetIdList
      Tags:
        - Key: Name
          Value: !Sub '${environment}-${serviceName}-${DBName}-subnet-group'
        - Key: Environment
          Value: !Ref environment

  ## ===================================
  ## PARAMETER CONFIGURATION
  ## ===================================

  # DATABASE CLUSTER PARAMETER GROUP
  AuroraDBClusterParameterGroup:
    Type: AWS::RDS::DBClusterParameterGroup
    Properties:
      Family: aurora-postgresql10
      Description: !Sub '${serviceName} Database Cluster Parameter Group'
      Parameters:
        rds.force_ssl: 1
        autovacuum_vacuum_scale_factor: 0.05
        log_statement: mod
      Tags:
        - Key: Name
          Value: !Sub '${environment}-${serviceName}-${DBName}-cluster-parameter-group'
        - Key: Environment
          Value: !Ref environment

  # DATABASE INSTANCE PARAMETER Group        
  AuroraDBInstanceParameterGroup:
    Type: AWS::RDS::DBParameterGroup
    Properties:
      Family: aurora-postgresql10
      Description: !Sub '${serviceName} Database Instance Parameter Group'
      Parameters:
        shared_preload_libraries: auto_explain,pg_stat_statements,pg_hint_plan,pgaudit
        log_statement: "mod" # changed to mod for Snowflake integration - check volumes and performance impact
        log_connections: 1
        log_disconnections: 1
        log_lock_waits: 1
        log_min_duration_statement: 5000
        auto_explain.log_min_duration: 5000
        auto_explain.log_verbose: 1
        log_rotation_age: 1440
        log_rotation_size: 102400
        rds.log_retention_period: 2880 # Reduced retention period to 2 days
        random_page_cost: 1
        track_activity_query_size: 16384
        idle_in_transaction_session_timeout: 7200000
        statement_timeout: 7200000
        search_path: '"$user",public'
        work_mem: 64000
      Tags:
        - Key: Name
          Value: !Sub '${environment}-${serviceName}-${DBName}-instance-parameter-group'
        - Key: Environment
          Value: !Ref environment

  ## ===================================
  ## ENCRYPTION CONFIGURATION
  ## ===================================

  # Main KMS Key
  AuroraKMSCMK:
    Type: 'AWS::KMS::Key'
    DeletionPolicy: Retain
    Properties:
      KeyPolicy:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            AWS: !Sub 'arn:aws:iam::${AWS::AccountId}:root'
          Action: 'kms:*'
          Resource: '*'
        - Effect: Allow
          Principal:
            AWS: '*'
          Action:
          - 'kms:Encrypt'
          - 'kms:Decrypt'
          - 'kms:ReEncrypt*'
          - 'kms:GenerateDataKey*'
          - 'kms:CreateGrant'
          - 'kms:ListGrants'
          - 'kms:DescribeKey'
          Resource: '*'
          Condition:
            StringEquals:
              'kms:CallerAccount': !Ref 'AWS::AccountId'
              'kms:ViaService': !Sub 'rds.${AWS::Region}.amazonaws.com'

  # KMS Alias
  AuroraKMSCMKAlias:
    Type: 'AWS::KMS::Alias'
    DeletionPolicy: Retain
    DependsOn: AuroraDBCluster
    Properties:
      AliasName: !Sub 'alias/${AuroraDBCluster}'
      TargetKeyId: !Ref AuroraKMSCMK

  ## ===================================
  ## PERFORMANCE CONFIGURATION
  ## ===================================
  
  # Monitoring Role
  MonitoringIAMRole: 
    Type: AWS::IAM::Role
    Condition: IsNotExampleEnv
    Properties: 
      AssumeRolePolicyDocument: 
        Version: "2012-10-17"
        Statement: 
          - 
            Effect: "Allow"
            Principal: 
              Service: 
                - "monitoring.rds.amazonaws.com"
            Action: 
              - "sts:AssumeRole"
      Path: "/"
      ManagedPolicyArns: 
        - arn:aws:iam::aws:policy/service-role/AmazonRDSEnhancedMonitoringRole

  ## ===================================
  ## INTEGRATION ROLE FOR AURORA CLUSTER
  ## ===================================
  
  # DB Export Role
  DBIntegrationIAMRole: 
    Type: AWS::IAM::Role
    Properties: 
      Path: "/"
      AssumeRolePolicyDocument: 
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - rds.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: RDSS3ImportPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: s3Export
                Effect: "Allow"
                Action: 
                  - "s3:PutObject"
                  - "s3:AbortMultipartUpload"
                Resource:
                  - !Join ['', [
                      !Ref referenceUserAssetsS3BucketArn,
                      '/*'
                  ]]

  # DB Import Role
  DBImportIAMRole: 
    Type: AWS::IAM::Role
    Properties: 
      Path: "/"
      AssumeRolePolicyDocument: 
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - rds.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: RDSS3ImportPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: s3Import
                Effect: "Allow"
                Action: 
                  - "s3:GetObject"
                  - "s3:ListBucket"
                Resource:
                  - !Ref referenceUserAssetsS3BucketArn
                  - !Join ['', [
                      !Ref referenceUserAssetsS3BucketArn,
                      '/*'
                  ]]
  ## ===================================
  ## RDS CLUSTER AND INSTANCES
  ## ===================================

  # AURORA RDS CLUSTER
  AuroraDBCluster:
    Type: 'AWS::RDS::DBCluster'
    DeletionPolicy: Snapshot
    UpdateReplacePolicy: Snapshot    
    Properties:
      AssociatedRoles:
        - FeatureName: s3Import
          RoleArn: !GetAtt DBImportIAMRole.Arn
        - FeatureName: s3Export
          RoleArn: !GetAtt DBIntegrationIAMRole.Arn
      BackupRetentionPeriod: !FindInMap [DBClusterConfig, !Ref environment, BackupRetentionPeriod]
      DatabaseName: !If [UsingSnapshot, !Ref "AWS::NoValue", !Ref DBName]
      DBSubnetGroupName: !Ref AuroraDBSubnetGroup
      DBClusterParameterGroupName: !Ref AuroraDBClusterParameterGroup
      Engine: !FindInMap [DBClusterConfig, !Ref environment, Engine]
      EngineVersion: !FindInMap [DBClusterConfig, !Ref environment, EngineVersion]
      MasterUsername: !If [UsingSnapshot, !Ref "AWS::NoValue", !Join ['', ['{{resolve:secretsmanager:', !Ref AuroraMasterSecret, ':SecretString:username}}' ]]]
      MasterUserPassword: !If [UsingSnapshot, !Ref "AWS::NoValue", !Join ['', ['{{resolve:secretsmanager:', !Ref AuroraMasterSecret, ':SecretString:password}}' ]]]
      PreferredBackupWindow: !FindInMap [DBClusterConfig, !Ref environment, PreferredBackupWindow]
      PreferredMaintenanceWindow: !FindInMap [DBClusterConfig, !Ref environment, PreferredMaintenanceWindow]
      Port: !FindInMap [DBClusterConfig, !Ref environment, PortNumber]
      SnapshotIdentifier: !If [UsingSnapshot, !Ref DBSnapshotArn, !Ref 'AWS::NoValue']
      StorageEncrypted:  !If [UsingSnapshot, !Ref "AWS::NoValue", true]
      KmsKeyId: !If [UsingSnapshot, !Ref 'AWS::NoValue', !Ref AuroraKMSCMK]
      EnableIAMDatabaseAuthentication: true
      Tags:
        - Key: Name
          Value: !Sub '${environment}-${serviceName}-${DBName}-datastore-cluster'
        - Key: Environment
          Value: !Ref environment
      VpcSecurityGroupIds:
        - !If [CreateLocalSecurityGroup, !GetAtt LocalClusterSecurityGroup.GroupId, !Ref referenceClusterSecurityGroupId] 

  # AURORA RDS INSTANCE 1
  AuroraDBInstance1:
    Type: 'AWS::RDS::DBInstance'
    Properties:
      AllowMajorVersionUpgrade: !FindInMap [DBInstanceConfig, !Ref environment, AllowMajorVersionUpgrade]
      AutoMinorVersionUpgrade: !FindInMap [DBInstanceConfig, !Ref environment, AutoMinorVersionUpgrade]      
      CopyTagsToSnapshot: true  
      DBClusterIdentifier: !Ref AuroraDBCluster
      DBInstanceClass: !FindInMap [DBInstanceConfig, !Ref environment, InstanceType]      
      DBParameterGroupName: !Ref AuroraDBInstanceParameterGroup      
      DBSubnetGroupName: !Ref AuroraDBSubnetGroup         
      EnablePerformanceInsights: true       
      Engine: !FindInMap [DBInstanceConfig, !Ref environment, Engine]
      EngineVersion: !FindInMap [DBInstanceConfig, !Ref environment, EngineVersion]
      MonitoringInterval: !FindInMap [DBInstanceConfig, !Ref environment, MonitoringInterval]
      MonitoringRoleArn: !If [IsNotExampleEnv, !GetAtt MonitoringIAMRole.Arn, !Ref "AWS::NoValue"]      
      PerformanceInsightsKMSKeyId: !Ref AuroraKMSCMK
      PerformanceInsightsRetentionPeriod: !FindInMap [DBInstanceConfig, !Ref environment, PerformanceInsightsRetentionPeriod]    
      PubliclyAccessible: !FindInMap [DBInstanceConfig, !Ref environment, PubliclyAccessible]
      Tags:
        - Key: Name
          Value: !Sub '${environment}-${serviceName}-${DBName}-datastore-instance-01'
        - Key: Environment
          Value: !Ref environment

  # AURORA RDS INSTANCE 2
  AuroraDBInstance2:
    Condition: IsNotExampleEnv
    Type: 'AWS::RDS::DBInstance'
    Properties:
      AllowMajorVersionUpgrade: !FindInMap [DBInstanceConfig, !Ref environment, AllowMajorVersionUpgrade]
      AutoMinorVersionUpgrade: !FindInMap [DBInstanceConfig, !Ref environment, AutoMinorVersionUpgrade]      
      CopyTagsToSnapshot: true  
      DBClusterIdentifier: !Ref AuroraDBCluster
      DBInstanceClass: !FindInMap [DBInstanceConfig, !Ref environment, InstanceType]      
      DBParameterGroupName: !Ref AuroraDBInstanceParameterGroup      
      DBSubnetGroupName: !Ref AuroraDBSubnetGroup         
      EnablePerformanceInsights: true       
      Engine: !FindInMap [DBInstanceConfig, !Ref environment, Engine]
      EngineVersion: !FindInMap [DBInstanceConfig, !Ref environment, EngineVersion]
      MonitoringInterval: !FindInMap [DBInstanceConfig, !Ref environment, MonitoringInterval]
      MonitoringRoleArn: !If [IsNotExampleEnv, !GetAtt MonitoringIAMRole.Arn, !Ref "AWS::NoValue"]      
      PerformanceInsightsKMSKeyId: !Ref AuroraKMSCMK
      PerformanceInsightsRetentionPeriod: !FindInMap [DBInstanceConfig, !Ref environment, PerformanceInsightsRetentionPeriod]    
      PubliclyAccessible: !FindInMap [DBInstanceConfig, !Ref environment, PubliclyAccessible]
      Tags:
        - Key: Name
          Value: !Sub '${environment}-${serviceName}-${DBName}-datastore-instance-01'
        - Key: Environment
          Value: !Ref environment

  ## ===================================
  ## ROUTE53
  ## ===================================

  # PRIVATE R53 RECORD SET: CLUSTER
  AuroraDBClusterRecordSet:
    Condition: UsingR53Zone
    Type: 'AWS::Route53::RecordSet'
    Properties:
      HostedZoneId:
        Fn::ImportValue:
          !Sub '${referenceZoneStack}-HostedZoneId'
      Name: !Sub
      - 'datastore.${Service}.${HostedZoneName}'
      - Service: !Ref serviceName
        HostedZoneName:
          Fn::ImportValue: 
            !Sub '${referenceZoneStack}-HostedZoneName'
      ResourceRecords:
      - !GetAtt [AuroraDBCluster, Endpoint.Address]     
      TTL: 60
      Type: CNAME

  # PRIVATE R53 RECORD SET: READ-ONLY
  AuroraDBClusterRORecordSet:
    Condition: UsingR53Zone
    Type: 'AWS::Route53::RecordSet'
    Properties:
      HostedZoneId:
        Fn::ImportValue:
          !Sub '${referenceZoneStack}-HostedZoneId'
      Name: !Sub
      - 'datastore.readonly.${Service}.${HostedZoneName}'
      - Service: !Ref serviceName
        HostedZoneName:
          Fn::ImportValue: 
            !Sub '${referenceZoneStack}-HostedZoneName'
      ResourceRecords:
      - !GetAtt [AuroraDBCluster, ReadEndpoint.Address]     
      TTL: 60
      Type: CNAME

  # PRIVATE R53 RECORD SET: INSTANCE 1
  AuroraDBInstance1RecordSet:
    Condition: UsingR53Zone
    Type: 'AWS::Route53::RecordSet'
    Properties:
      HostedZoneId:
        Fn::ImportValue: 
          !Sub '${referenceZoneStack}-HostedZoneId'
      Name: !Sub
      - 'datastore.inst1.${Service}.${HostedZoneName}'
      - Service: !Ref serviceName
        HostedZoneName:
          Fn::ImportValue: 
            !Sub '${referenceZoneStack}-HostedZoneName'
      ResourceRecords:
      - !GetAtt [AuroraDBInstance1, Endpoint.Address]
      TTL: 60
      Type: CNAME

  # PRIVATE R53 RECORD SET: INSTANCE 2
  AuroraDBInstance2RecordSet:
    Condition: IsNotExampleAndUsingR53Zone
    Type: 'AWS::Route53::RecordSet'
    Properties:
      HostedZoneId:
        Fn::ImportValue:
          !Sub '${referenceZoneStack}-HostedZoneId'
      Name: !Sub
      - 'datastore.inst2.${Service}.${HostedZoneName}'
      - Service: !Ref serviceName
        HostedZoneName:
          Fn::ImportValue: 
            !Sub '${referenceZoneStack}-HostedZoneName'
      ResourceRecords:
      - !GetAtt [AuroraDBInstance2, Endpoint.Address]
      TTL: 60
      Type: CNAME

  ## ===================================
  ## ALARMS - DB INSTANCE 01
  ## ===================================

  DBBurstBalanceTooLowAlarm1:
    Condition: UsingExistingAlertTopic
    Type: 'AWS::CloudWatch::Alarm'
    Properties:
      AlarmDescription: 'Average database storage burst balance over last 10 minutes lower than 20%, expect a significant performance drop soon'
      Namespace: 'AWS/RDS'
      MetricName: BurstBalance
      Statistic: Average
      Period: 600
      EvaluationPeriods: 1
      ComparisonOperator: LessThanThreshold
      Threshold: 20
      AlarmActions:
      - Fn::ImportValue: 
          !Sub '${referenceAlertStack}-TopicARN'
      Dimensions:
      - Name: DBInstanceIdentifier
        Value: !Ref AuroraDBInstance1

  DBCPUUtilizationTooHighAlarm1:
    Condition: UsingExistingAlertTopic
    Type: 'AWS::CloudWatch::Alarm'
    Properties:
      ActionsEnabled: true
      AlarmActions:
      - Fn::ImportValue:
          !Sub '${referenceAlertStack}-TopicARN'      
      AlarmDescription: 'Average database CPU utilization over last 5 minutes higher than 80%'
      Dimensions:
      - Name: DBInstanceIdentifier
        Value: !Ref AuroraDBInstance1
      
      Namespace: 'AWS/RDS'
      MetricName: CPUUtilization
      Statistic: Maximum
      Period: 60
      EvaluationPeriods: 5
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Threshold: 80
      TreatMissingData: 'notBreaching'      
      Unit: Percent

  DBDiskQueueDepthTooHighAlarm1:
    Condition: UsingExistingAlertTopic
    Type: 'AWS::CloudWatch::Alarm'
    Properties:
      AlarmDescription: 'Average database disk queue depth over last 10 minutes higher than 64, performance may suffer'
      Namespace: 'AWS/RDS'
      MetricName: DiskQueueDepth
      Statistic: Average
      Period: 600
      EvaluationPeriods: 1
      ComparisonOperator: GreaterThanThreshold
      Threshold: 64
      AlarmActions:
      - Fn::ImportValue: 
          !Sub '${referenceAlertStack}-TopicARN'
      Dimensions:
      - Name: DBInstanceIdentifier
        Value: !Ref AuroraDBInstance1

  DBFreeableMemoryTooLowAlarm1:
    Condition: UsingExistingAlertTopic
    Type: 'AWS::CloudWatch::Alarm'
    Properties:
      AlarmDescription: 'Average database freeable memory over last 10 minutes lower than 64 MB, performance may suffer'
      Namespace: 'AWS/RDS'
      MetricName: FreeableMemory
      Statistic: Average
      Period: 600
      EvaluationPeriods: 1
      ComparisonOperator: LessThanThreshold
      Threshold: 67108864 # 64 MB in Bytes
      AlarmActions:
      - Fn::ImportValue:
          !Sub '${referenceAlertStack}-TopicARN'
      Dimensions:
      - Name: DBInstanceIdentifier
        Value: !Ref AuroraDBInstance1

  DBFreeStorageSpaceTooLowAlarm1:
    Condition: UsingExistingAlertTopic
    Type: 'AWS::CloudWatch::Alarm'
    Properties:
      AlarmDescription: 'Average database free storage space over last 10 minutes lower than 2 GB'
      Namespace: 'AWS/RDS'
      MetricName: FreeStorageSpace
      Statistic: Average
      Period: 600
      EvaluationPeriods: 1
      ComparisonOperator: LessThanThreshold
      Threshold: 2147483648 # 2 GB in Bytes
      AlarmActions:
      - Fn::ImportValue: 
          !Sub '${referenceAlertStack}-TopicARN'
      Dimensions:
      - Name: DBInstanceIdentifier
        Value: !Ref AuroraDBInstance1

  DBSwapUsageTooHighAlarm1:
    Condition: UsingExistingAlertTopic
    Type: 'AWS::CloudWatch::Alarm'
    Properties:
      AlarmDescription: 'Average database swap usage over last 10 minutes higher than 256 MB, performance may suffer'
      Namespace: 'AWS/RDS'
      MetricName: SwapUsage
      Statistic: Average
      Period: 600
      EvaluationPeriods: 1
      ComparisonOperator: GreaterThanThreshold
      Threshold: 268435456 # 256 MB in Bytes
      AlarmActions:
      - Fn::ImportValue: 
          !Sub '${referenceAlertStack}-TopicARN'
      Dimensions:
      - Name: DBInstanceIdentifier
        Value: !Ref AuroraDBInstance1

  DBMaxUsedTxIDsAlarm1:
    Condition: UsingExistingAlertTopic
    Type: 'AWS::CloudWatch::Alarm'
    Properties:
      ActionsEnabled: true
      AlarmActions:
      - Fn::ImportValue: 
          !Sub '${referenceAlertStack}-TopicARN'
      AlarmDescription: 'Maximum Used Transaction IDs'
      Dimensions:
      - Name: DBInstanceIdentifier
        Value: !Ref AuroraDBInstance1
      MetricName: 'MaximumUsedTransactionIDs'
      Statistic: Average
      Namespace: 'AWS/RDS'
      Threshold: 600000000
      Unit: Count
      ComparisonOperator: 'GreaterThanOrEqualToThreshold'
      Period: 60
      EvaluationPeriods: 5
      TreatMissingData: 'notBreaching'

  ## ===================================
  ## ALARMS - DB INSTANCE 02
  ## ===================================

  DBBurstBalanceTooLowAlarm2:
    Condition: IsNotExampleAndUsingExistingAlertTopic
    Type: 'AWS::CloudWatch::Alarm'
    Properties:
      AlarmDescription: 'Average database storage burst balance over last 10 minutes lower than 20%, expect a significant performance drop soon'
      Namespace: 'AWS/RDS'
      MetricName: BurstBalance
      Statistic: Average
      Period: 600
      EvaluationPeriods: 1
      ComparisonOperator: LessThanThreshold
      Threshold: 20
      AlarmActions:
      - Fn::ImportValue: 
          !Sub '${referenceAlertStack}-TopicARN'
      Dimensions:
      - Name: DBInstanceIdentifier
        Value: !Ref AuroraDBInstance2

  DBCPUUtilizationTooHighAlarm2:
    Condition: IsNotExampleAndUsingExistingAlertTopic
    Type: 'AWS::CloudWatch::Alarm'
    Properties:
      ActionsEnabled: true
      AlarmActions:
      - Fn::ImportValue:
          !Sub '${referenceAlertStack}-TopicARN'      
      AlarmDescription: 'Average database CPU utilization over last 5 minutes higher than 80%'
      Dimensions:
      - Name: DBInstanceIdentifier
        Value: !Ref AuroraDBInstance2
      
      Namespace: 'AWS/RDS'
      MetricName: CPUUtilization
      Statistic: Maximum
      Period: 60
      EvaluationPeriods: 5
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Threshold: 80
      TreatMissingData: 'notBreaching'      
      Unit: Percent

  DBDiskQueueDepthTooHighAlarm2:
    Condition: IsNotExampleAndUsingExistingAlertTopic
    Type: 'AWS::CloudWatch::Alarm'
    Properties:
      AlarmDescription: 'Average database disk queue depth over last 10 minutes higher than 64, performance may suffer'
      Namespace: 'AWS/RDS'
      MetricName: DiskQueueDepth
      Statistic: Average
      Period: 600
      EvaluationPeriods: 1
      ComparisonOperator: GreaterThanThreshold
      Threshold: 64
      AlarmActions:
      - Fn::ImportValue: 
          !Sub '${referenceAlertStack}-TopicARN'
      Dimensions:
      - Name: DBInstanceIdentifier
        Value: !Ref AuroraDBInstance2

  DBFreeableMemoryTooLowAlarm2:
    Condition: IsNotExampleAndUsingExistingAlertTopic
    Type: 'AWS::CloudWatch::Alarm'
    Properties:
      AlarmDescription: 'Average database freeable memory over last 10 minutes lower than 64 MB, performance may suffer'
      Namespace: 'AWS/RDS'
      MetricName: FreeableMemory
      Statistic: Average
      Period: 600
      EvaluationPeriods: 1
      ComparisonOperator: LessThanThreshold
      Threshold: 67108864 # 64 MB in Bytes
      AlarmActions:
      - Fn::ImportValue: 
          !Sub '${referenceAlertStack}-TopicARN'
      Dimensions:
      - Name: DBInstanceIdentifier
        Value: !Ref AuroraDBInstance2

  DBFreeStorageSpaceTooLowAlarm2:
    Condition: IsNotExampleAndUsingExistingAlertTopic
    Type: 'AWS::CloudWatch::Alarm'
    Properties:
      AlarmDescription: 'Average database free storage space over last 10 minutes lower than 2 GB'
      Namespace: 'AWS/RDS'
      MetricName: FreeStorageSpace
      Statistic: Average
      Period: 600
      EvaluationPeriods: 1
      ComparisonOperator: LessThanThreshold
      Threshold: 2147483648 # 2 GB in Bytes
      AlarmActions:
      - Fn::ImportValue: 
          !Sub '${referenceAlertStack}-TopicARN'
      Dimensions:
      - Name: DBInstanceIdentifier
        Value: !Ref AuroraDBInstance2

  DBSwapUsageTooHighAlarm2:
    Condition: IsNotExampleAndUsingExistingAlertTopic
    Type: 'AWS::CloudWatch::Alarm'
    Properties:
      AlarmDescription: 'Average database swap usage over last 10 minutes higher than 256 MB, performance may suffer'
      Namespace: 'AWS/RDS'
      MetricName: SwapUsage
      Statistic: Average
      Period: 600
      EvaluationPeriods: 1
      ComparisonOperator: GreaterThanThreshold
      Threshold: 268435456 # 256 MB in Bytes
      AlarmActions:
      - Fn::ImportValue: 
          !Sub '${referenceAlertStack}-TopicARN'
      Dimensions:
      - Name: DBInstanceIdentifier
        Value: !Ref AuroraDBInstance2

  DBMaxUsedTxIDsAlarm2:
    Condition: IsNotExampleAndUsingExistingAlertTopic
    Type: 'AWS::CloudWatch::Alarm'
    Properties:
      ActionsEnabled: true
      AlarmActions:
      - Fn::ImportValue: 
          !Sub '${referenceAlertStack}-TopicARN'
      AlarmDescription: 'Maximum Used Transaction IDs'
      Dimensions:
      - Name: DBInstanceIdentifier
        Value: !Ref AuroraDBInstance2
      MetricName: 'MaximumUsedTransactionIDs'
      Statistic: Average
      Namespace: 'AWS/RDS'
      Threshold: 600000000
      Unit: Count
      ComparisonOperator: 'GreaterThanOrEqualToThreshold'
      Period: 60
      EvaluationPeriods: 5
      TreatMissingData: 'notBreaching'

  ## ===================================
  ## EVENT NOTIFICATIONS
  ## ===================================
  DBClusterEventSubscription:
    Condition: UsingExistingAlertTopic    
    Type: 'AWS::RDS::EventSubscription'    
    Properties:
      EventCategories:
      - failover
      - failure
      - notification
      SnsTopicArn: 
        Fn::ImportValue: 
          !Sub '${referenceAlertStack}-TopicARN'        
      SourceIds: [!Ref AuroraDBCluster]
      SourceType: 'db-cluster'

  DatabaseInstanceEventSubscription:
    Condition: UsingExistingAlertTopic
    Type: 'AWS::RDS::EventSubscription'
    Properties:
      EventCategories:
      - availability
      - configuration change
      - deletion
      - failover
      - failure
      - maintenance
      - notification
      - recovery
      SnsTopicArn: 
        Fn::ImportValue: 
          !Sub '${referenceAlertStack}-TopicARN'
      SourceIds: 
      - !Ref AuroraDBInstance1
      - !If [ IsNotExampleAndUsingExistingAlertTopic, !Ref AuroraDBInstance2, !Ref "AWS::NoValue"]
      SourceType: 'db-instance'
      
  DBParameterGroupEventSubscription:
    Condition: UsingExistingAlertTopic
    Type: 'AWS::RDS::EventSubscription'
    Properties:
      EventCategories:
      - configuration change
      SnsTopicArn: 
        Fn::ImportValue: 
          !Sub '${referenceAlertStack}-TopicARN'
      SourceIds: 
        - !Ref AuroraDBInstanceParameterGroup
      SourceType: 'db-parameter-group'

# -----------
# SSM Parameters
# -----------

  # Aurora DataStore Cluster Name
  AuroraDBClusterName:
    Type: AWS::SSM::Parameter
    Properties: 
      Description: !Sub "Name of the Aurora Cluster for the ${serviceName} service in the ${environment} environment"
      Name: !Sub
        - '/${env}/${service}/aurora/cluster/name'
        - {
          env: !FindInMap [ EnvConfig, !Ref environment, EnvToLower ],
          service: !Ref serviceName
          }
      Type: 'String'
      Value: !Ref AuroraDBCluster
      # Tag Config
      Tags:        
        Service: !Sub '${serviceName}'
        Environment: !Ref environment

  # Aurora DataStore Cluster Endpoint
  AuroraDBClusterEndpoint:
    Type: AWS::SSM::Parameter
    Properties: 
      Description: !Sub "Endpoint of the Aurora Cluster for the ${serviceName} service in the ${environment} environment"
      Name: !Sub
        - '/${env}/${service}/aurora/cluster/endpoint'
        - {
          env: !FindInMap [ EnvConfig, !Ref environment, EnvToLower ],
          service: !Ref serviceName
          }
      Type: 'String'
      Value: !GetAtt AuroraDBCluster.Endpoint.Address
      # Tag Config
      Tags:        
        Service: !Sub '${serviceName}'
        Environment: !Ref environment

  # Aurora DataStore Cluster Read Endpoint
  AuroraDBClusterReadEndpoint:
    Type: AWS::SSM::Parameter
    Properties: 
      Description: !Sub "Read-Only endpoint of the Aurora Cluster for the ${serviceName} service in the ${environment} environment"
      Name: !Sub
        - '/${env}/${service}/aurora/cluster/read-endpoint'
        - {
          env: !FindInMap [ EnvConfig, !Ref environment, EnvToLower ],
          service: !Ref serviceName
          }
      Type: 'String'
      Value: !GetAtt AuroraDBCluster.ReadEndpoint.Address
      # Tag Config
      Tags:        
        Service: !Sub '${serviceName}'
        Environment: !Ref environment

  # Aurora DataStore Cluster Port
  AuroraDBClusterPort:
    Type: AWS::SSM::Parameter
    Properties: 
      Description: !Sub "Aurora Cluster port for the ${serviceName} service in the ${environment} environment"
      Name: !Sub
        - '/${env}/${service}/aurora/cluster/port'
        - {
          env: !FindInMap [ EnvConfig, !Ref environment, EnvToLower ],
          service: !Ref serviceName
          }
      Type: 'String'
      Value: !GetAtt AuroraDBCluster.Endpoint.Port
      # Tag Config
      Tags:        
        Service: !Sub '${serviceName}'
        Environment: !Ref environment

  # Aurora DataStore Cluster DBName
  AuroraDBClusterDBName:
    Type: AWS::SSM::Parameter
    Properties: 
      Description: !Sub "Aurora Cluster database name for the ${serviceName} service in the ${environment} environment"
      Name: !Sub
        - '/${env}/${service}/aurora/cluster/db-name'
        - {
          env: !FindInMap [ EnvConfig, !Ref environment, EnvToLower ],
          service: !Ref serviceName
          }
      Type: 'String'
      Value: !Ref DBName
      # Tag Config
      Tags:        
        Service: !Sub '${serviceName}'
        Environment: !Ref environment

# -----------
# OUTPUTS
# -----------
Outputs:

  TemplateID:
    Description: 'Template id'
    Value: 'db/rdscluster'
  
  StackName:
    Description: 'Stack name'
    Value: !Sub '${AWS::StackName}'

#--

  AuroraDBCluster:
    Description: 'Aurora database cluster'
    Value: !Ref AuroraDBCluster
    Export:
      Name: !Sub '${AWS::StackName}-DBCluster'

  AuroraDBClusterEndpoint:
    Description: 'Aurora cluster endpoint address'
    Value: !GetAtt AuroraDBCluster.Endpoint.Address
    Export:
      Name: !Sub '${AWS::StackName}-DBClusterEndpoint'

  AuroraDBClusterReadEndpoint:
    Description: 'Aurora cluster read endpoint address'
    Value: !GetAtt AuroraDBCluster.ReadEndpoint.Address
    Export:
      Name: !Sub '${AWS::StackName}-DBClusterReadEndpoint'

  AuroraDBClusterPort:
    Description: 'Aurora cluster endpoint port'
    Value: !GetAtt AuroraDBCluster.Endpoint.Port

  AuroraDBClusterDBName:
    Description: 'Aurora cluster endpoint database name'
    Value: !Ref DBName

  AuroraDBClusterJDBCConnectionString:
    Description: 'JDBC connection string for the database cluster'
    Value: !Join ['', [
      'jdbc:postgresql://', 
      !GetAtt AuroraDBCluster.Endpoint.Address,
      ':', 
      !GetAtt AuroraDBCluster.Endpoint.Port, 
      /, 
      !Ref 'DBName']]

  AuroraDBClusterPSQLCommandLine:    
    Description: PSQL Command Line
    Value: !Join
             - ''
             - - 'psql --host='
               - !GetAtt 'AuroraDBCluster.Endpoint.Address' 
               - ' --port='
               - !GetAtt 'AuroraDBCluster.Endpoint.Port'
               - ' --username=master --dbname='              
               - !Ref DBName
#--

  AuroraDBInstance1:
    Description: 'Aurora database instance 1'
    Value: !Ref AuroraDBInstance1
    Export:
      Name: !Sub '${AWS::StackName}-DB1'

  AuroraDBInstance1Endpoint:
    Description: 'Aurora database instance 1 endpoint'
    Value: !GetAtt AuroraDBInstance1.Endpoint.Address
    Export:
      Name: !Sub '${AWS::StackName}-DB1Endpoint'

  AuroraDBInstance1JDBCConnectionString:
    Description: 'JDBC connection string for database instance 2'
    Value: !Join ['', [
      'jdbc:postgresql://', 
      !GetAtt AuroraDBInstance1.Endpoint.Address,
      ':', 
      !GetAtt AuroraDBInstance1.Endpoint.Port, 
      /, 
      !Ref 'DBName']]

#--

  AuroraDBInstance2:
    Condition: IsNotExampleEnv
    Description: 'Aurora database instance 2'
    Value: !Ref AuroraDBInstance2
    Export:
      Name: !Sub '${AWS::StackName}-DB2'

  AuroraDBInstance2Endpoint:
    Condition: IsNotExampleEnv
    Description: 'Aurora database instance 2 endpoint'
    Value: !GetAtt AuroraDBInstance2.Endpoint.Address
    Export:
      Name: !Sub '${AWS::StackName}-DB2Endpoint'

  AuroraDBInstance1JDBCConnectionString:
    Condition: IsNotExampleEnv
    Description: 'JDBC connection string for database instance 1'
    Value: !Join ['', [
      'jdbc:postgresql://', 
      !GetAtt AuroraDBInstance1.Endpoint.Address,
      ':', 
      !GetAtt AuroraDBInstance1.Endpoint.Port, 
      /, 
      !Ref 'DBName']]      